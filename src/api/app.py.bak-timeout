# src/api/app.py
"""
FastAPI wrapper around the Climate RAG pipeline.
Robust: lazy-instantiates heavy components and handles missing/variant constructors.
"""
import traceback
from pathlib import Path
from fastapi import FastAPI

def _attach_search(retriever):
    """
    Ensure the retriever object has a 'search(query, k=5)' method.
    This attaches a small adapter to call the best available method:
    prefer retrieve(), then query(), then tfidf().
    """
    if retriever is None:
        return retriever
    # if already has search, nothing to do
    if hasattr(retriever, "search"):
        return retriever
    # attach adapters based on available methods
    if hasattr(retriever, "retrieve"):
        try:
            retriever.search = lambda q, k=5, **kwargs: retriever.retrieve(q, k)
            return retriever
        except Exception:
            pass
    if hasattr(retriever, "query"):
        try:
            # support different arg names
            def _q(q, k=5, **kwargs):
                # try common signatures
                try:
                    return retriever.query(q, top_k=k)
                except TypeError:
                    return retriever.query(q, k)
            retriever.search = _q
            return retriever
        except Exception:
            pass
    if hasattr(retriever, "tfidf"):
        try:
            retriever.search = lambda q, k=5, **kwargs: retriever.tfidf(q, k)
            return retriever
        except Exception:
            pass
    # fallback: no-op search
    retriever.search = lambda q, k=5, **kwargs: []
    return retriever
, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
import shutil

# lazy placeholders
_orch = None
_retriever = None

def get_orchestrator():
    global _orch
    if _orch is not None:
        return _orch
    try:
        # import lazily so startup errors are visible and handled
        from core.orchestrator import PipelineOrchestrator
        _orch = PipelineOrchestrator()
        return _orch
    except Exception:
        traceback.print_exc()
        raise

def build_candidate_docs():
    """
    Return a reasonable default list/path to pass to Retriever if needed.
    We prefer the index folder if present, otherwise the text folder.
    """
    repo_root = Path.cwd()
    # prefer data/index
    idx = repo_root / "data" / "index"
    txt = repo_root / "data" / "text"
    if idx.exists():
        return {"index_dir": str(idx)}
    if txt.exists():
        # pass a list of text files or the folder path depending on Retriever signature
        return {"docs": [str(p) for p in sorted(txt.glob("*.txt"))]}
    return {}


def get_retriever():
    """
    Lazily instantiate Retriever using a list of docs constructed from data/text/*.txt.
    This uses the positional 'docs' constructor which is required by this Retriever.
    """
    global _retriever
    if _retriever is not None:
        try:
            _attach_search(_retriever)
        except Exception:
            pass
        return _retriever

    try:
        from core.retrieval import Retriever
    except Exception:
        import traceback
        traceback.print_exc()
        return None

    # Build docs list as [{"id": filename, "text": file_contents, "source": path}, ...]
    docs = []
    try:
        from pathlib import Path as _P
        txt_dir = _P.cwd() / "data" / "text"
        if txt_dir.exists():
            for fp in sorted(txt_dir.glob("*.txt")):
                try:
                    text = fp.read_text(encoding="utf-8")
                except Exception:
                    text = ""
                docs.append({"id": fp.name, "text": text, "source": str(fp.resolve())})
    except Exception:
        docs = []

    # Preferred constructor: positional docs list
    try:
        if docs:
            _retriever = Retriever(docs)
            try:
            _attach_search(_retriever)
        except Exception:
            pass
        return _retriever
    except Exception:
        import traceback
        traceback.print_exc()

    # Fallbacks (try default/no-arg, then index path)
    try:
        _retriever = Retriever()
        try:
            _attach_search(_retriever)
        except Exception:
            pass
        return _retriever
    except Exception:
        pass

    try:
        idx = str((_P.cwd() / "data" / "index").resolve())
        _retriever = Retriever(idx)
        try:
            _attach_search(_retriever)
        except Exception:
            pass
        return _retriever
    except Exception:
        pass

    print("[WARN] Could not construct Retriever with tried signatures.")
    return None

app = FastAPI(title="Climate RAG API (robust)")

# allow local dev UI (be cautious in production)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/health")
def health():
    return {"status": "ok"}


@app.post("/process")
async def process(file: UploadFile = File(...)):
    """
    Accepts a single file upload and processes it via the orchestrator.
    Returns the summary JSON produced by the pipeline.
    """
    try:
        orch = get_orchestrator()
    except Exception as e:
        return {"error": "orchestrator_unavailable", "detail": str(e)}

    UPLOAD_DIR = Path("uploads")
    UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

    temp_path = UPLOAD_DIR / file.filename
    try:
        with open(temp_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
    except Exception as e:
        return {"error": "upload_failed", "detail": str(e)}

    suf = temp_path.suffix.lower()
    try:
        if suf == ".pdf":
            out = orch.process_pdf(temp_path)
        elif suf in [".jpg", ".jpeg", ".png", ".webp"]:
            out = orch.process_image(temp_path)
        elif suf in [".wav", ".mp3"]:
            out = orch.process_audio(temp_path)
        else:
            # treat as text by default
            out = orch.process_text(temp_path)
    except Exception as e:
        traceback.print_exc()
        return {"error": "processing_failed", "detail": str(e)}

    return out


@app.post("/query")
async def query(payload: dict):
    q = payload.get("query", "")
    if not q:
        return {"error": "missing_query"}

    retr = get_retriever()
    if retr is None:
        return {"error": "retriever_unavailable", "detail": "Could not instantiate Retriever; check core/retrieval.py"}

    # some Retriever implementations may provide a `search` or `query` method
    try:
        if hasattr(retr, "search"):
            return retr.search(q, k=5)
        elif hasattr(retr, "query"):
            return retr.query(q, top_k=5)
        else:
            return {"error": "retriever_interface_unknown", "detail": "Retriever has no search/query method"}
    except Exception as e:
        traceback.print_exc()
        return {"error": "retrieval_failed", "detail": str(e)}
