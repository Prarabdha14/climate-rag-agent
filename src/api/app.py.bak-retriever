# src/api/app.py
"""
FastAPI wrapper around the Climate RAG pipeline.
Robust: lazy-instantiates heavy components and handles missing/variant constructors.
"""
import traceback
from pathlib import Path
from fastapi import FastAPI, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
import shutil

# lazy placeholders
_orch = None
_retriever = None

def get_orchestrator():
    global _orch
    if _orch is not None:
        return _orch
    try:
        # import lazily so startup errors are visible and handled
        from core.orchestrator import PipelineOrchestrator
        _orch = PipelineOrchestrator()
        return _orch
    except Exception:
        traceback.print_exc()
        raise

def build_candidate_docs():
    """
    Return a reasonable default list/path to pass to Retriever if needed.
    We prefer the index folder if present, otherwise the text folder.
    """
    repo_root = Path.cwd()
    # prefer data/index
    idx = repo_root / "data" / "index"
    txt = repo_root / "data" / "text"
    if idx.exists():
        return {"index_dir": str(idx)}
    if txt.exists():
        # pass a list of text files or the folder path depending on Retriever signature
        return {"docs": [str(p) for p in sorted(txt.glob("*.txt"))]}
    return {}

def get_retriever():
    """
    TEMPORARY STUB: return None quickly to avoid blocking the server while Retriever is debugged.
    This prevents /query from hanging. Replace this stub with the full get_retriever implementation
    after Retriever issues are resolved.
    """
    return None

app = FastAPI(title="Climate RAG API (robust)")

# allow local dev UI (be cautious in production)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/health")
def health():
    return {"status": "ok"}


@app.post("/process")
async def process(file: UploadFile = File(...)):
    """
    Accepts a single file upload and processes it via the orchestrator.
    Returns the summary JSON produced by the pipeline.
    """
    try:
        orch = get_orchestrator()
    except Exception as e:
        return {"error": "orchestrator_unavailable", "detail": str(e)}

    UPLOAD_DIR = Path("uploads")
    UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

    temp_path = UPLOAD_DIR / file.filename
    try:
        with open(temp_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
    except Exception as e:
        return {"error": "upload_failed", "detail": str(e)}

    suf = temp_path.suffix.lower()
    try:
        if suf == ".pdf":
            out = orch.process_pdf(temp_path)
        elif suf in [".jpg", ".jpeg", ".png", ".webp"]:
            out = orch.process_image(temp_path)
        elif suf in [".wav", ".mp3"]:
            out = orch.process_audio(temp_path)
        else:
            # treat as text by default
            out = orch.process_text(temp_path)
    except Exception as e:
        traceback.print_exc()
        return {"error": "processing_failed", "detail": str(e)}

    return out


@app.post("/query")
async def query(payload: dict):
    q = payload.get("query", "")
    if not q:
        return {"error": "missing_query"}

    retr = get_retriever()
    if retr is None:
        return {"error": "retriever_unavailable", "detail": "Could not instantiate Retriever; check core/retrieval.py"}

    # some Retriever implementations may provide a `search` or `query` method
    try:
        if hasattr(retr, "search"):
            return retr.search(q, k=5)
        elif hasattr(retr, "query"):
            return retr.query(q, top_k=5)
        else:
            return {"error": "retriever_interface_unknown", "detail": "Retriever has no search/query method"}
    except Exception as e:
        traceback.print_exc()
        return {"error": "retrieval_failed", "detail": str(e)}
